#pragma config(Sensor, in1,    motor_angle,    sensorPotentiometer)
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************************
** bool set_motor( int target )
** Runs motor to try and hit target angle
** Inputs:
**   target  - target reading from potentiometer.
** Output:
**    true   - motor has reached desired position
**    false  - motor has not hit target position
**
** Sets motor output.
** Reads motor from port motor_angle
**********************************************************/
bool set_motor(int target)//Target position of motor.
{
	//Measure the current motor position
	int pos = SensorValue[motor_angle];
	int MAX = 50; //Maximum amplitude of motor control signal.
	int ACC = 10; //Desired accuracy of position.



	// Compute difference from current position and target position.
	int delta = target - pos;

	// If motor is within the accuracy of the target position, turn motor off and return.
	if (delta == 0 || delta <= ACC && delta >= -ACC) {
		//Shut off motor
		motor[motor1] = 0;
		return true;
	}

	// If delta is positive, we are below the target. Run motor positively.
	if (delta > 0) {

		// The closer we are to the target, the slower the motor. This enhances accuracy when target is hit.
		writeDebugStream("Delta > 0. (%d)\n",delta);
		motor[motor1] = delta < MAX ? delta : MAX;
	}
	else if (delta < 0) {

		// If current position is higher than target position, run motor with negative control.
		// We run at the maximum speed possible unless we are within range of the target.
		writeDebugStream("Delta < 0. (%d)\n", delta);
		motor[motor1] = delta > -MAX ? -delta : -MAX;
	}

	//We only get here if we're not at the target, so return false
	return false;
}

task main()
{
	// Target value to move motor towards.
	int target_value = 1500;

	// Time unitl motor hits target value.
	int first_time=0;
	// Maximum error after first time motor hits target value.
	int max_error=0;
	// Noted if motor hit target value.
	bool hit_target = false;

	int delta = 0; // The difference between current position and target.

	// Reset timer.
	clearTimer(T1);

	// Run for either 5 seconds or until we get to target value
	while (time1(T1) < 5000 || !hit_Target) {

		// Implements one iteration of control algorithm.
		hit_target = set_motor(target_value);

		// If we haven't hit target value yet...
		if (!hit_target) {
			// Check if we encounter target_value again.
			if (SensorValue[motor_angle] == target_value) {
				// Note hit target value.
				writeDebugStream("Target hit in main. (%d)\n", target_value);
				hit_target = true;

				// Record first time.
				first_time = time1(T1);

				// Reset maximum error value.
				max_error = 0;
			}
		}
		else {

			// Find deviation from target value.
			delta = target_value - SensorValue[motor_angle];
			writeDebugStream("Computing new delta in main. (%d)\n", delta);

			// Find absolute value of deviation.
			if (delta < 0) {
				delta = -1 * delta;
			}

			// If deviation is larger then previously found maximum deviation, update maximum deviation.
			if (delta > max_error) {
				max_error = delta;
			}

		} // if (! hit_target) else
	}  // match while( time1(T1) < 5000 )

	// Turn off motor
	motor[motor1] = 0;

	// Record results.
	if (hit_target) {
		writeDebugStream("First Time: %d\tMax Error: %d\n", first_time, max_error);
	}
	else {
		writeDebugStream("No convergence.\n");
	}

	// Infinite loop to keep DebugStream open so output can be read.
	while (1);
}
