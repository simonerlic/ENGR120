#pragma config(Sensor, in7,    l_lightSensor,  sensorReflection)
#pragma config(Sensor, in8,    r_lightSensor,  sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl7,  c_signalLED,    sensorDigitalOut)
#pragma config(Sensor, dgtl8,  r_signalLED,    sensorDigitalOut)
#pragma config(Sensor, dgtl9,  l_signalLED,    sensorDigitalOut)
#pragma config(Sensor, dgtl10, sonarSensor,    sensorSONAR_cm)
#pragma config(Motor,  port1,           motor_left,    tmotorVex393_HBridge, openLoop, reversed, driveLeft)
#pragma config(Motor,  port2,           grabber,       tmotorVex269_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          motor_right,   tmotorVex393_HBridge, openLoop, reversed, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

enum T_STATES{STOPPED,FORWARD,REVERSE,SCANNING,FINISH, RELEASE, CALIBRATE};
enum T_LED {ON,OFF};
bool is_dropped = false;//Flag used to signal when payload has been dropped.
bool is_completed = true;
const int threshold = 2;//Distance in centimeters to stop the vehicle.
const int slow = 50;//Value used in determining vehicle wheel speed.
const int fast = 127;//Value used in determining vehicle wheel speed.
const int maxLight = 30;//a light sensor value used in determining whether we are at the target location.

//Calibration variables
int diff = 0;
int leftLow = 1000; //Registers the lowest value captured from the left light sensor during calibration.
int rightLow = 1000; //Registers the lowest value czptured from the right light sensor during calibration.
int leftHigh = 0;// Registers the high value (lighter) for the left sensor, set when calibrating.
int rightHigh = 0;//Registers the high value (lighter) for the right sensor, set when calibrating.
int leftValue = 0;//The current light measurement from the left light sensor, set when calibrating.
int rightValue = 0;//The current light measurement from the right light sensor, set when calibrating.

bool button1_pushed; //flag to store button1 input


/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released
*/
void monitorInput()
{
	if (SensorValue(button1) && !button1_pushed)
	{
		writeDebugStreamLine("button1_pushed=true");
		button1_pushed = true;
	}
}
/*
//Light Methods
*/
void do_lightRightLED(){
	T_LED LED=ON;
	SensorValue[r_signalLED] = LED;
}

void do_lightLeftLED(){
	T_LED LED=ON;
	SensorValue[l_signalLED] = LED;
}

void do_lightCenterLED(){
	T_LED LED=ON;
	SensorValue[c_signalLED] = LED;
}

void do_unlightRightLED(){
	T_LED LED=OFF;
	SensorValue[r_signalLED] = LED;
}

void do_unlightLeftLED(){
	T_LED LED=OFF;
	SensorValue[l_signalLED] = LED;
}

void do_unlightCenterLED(){
	T_LED LED=OFF;
	SensorValue[c_signalLED] = LED;
}

/*
//Just fancy lighting effects
*/
void do_scanningStartLED(){
	do_lightLeftLED();
	wait1Msec(100);
	do_lightCenterLED();
	wait1Msec(100);
	do_lightRightLED();
}

void do_scanningStopLED(){
	do_unlightLeftLED();
	wait1Msec(100);
	do_unlightCenterLED();
	wait1Msec(100);
	do_unlightRightLED();
}

/*
This method is used to release the object while it is on the front scaffolding
The scaffolding is turned by one motor which rotates to release the object
*/
void do_release(int speed){
	if(!is_dropped){
		writeDebugStreamLine("Releasing at speed %d ...",speed);
		clearTimer(T1);
		while(time1[T1]<1000){//gotta figure out how long to drop payload
			do_scanningStartLED();
			motor[grabber] = speed;
			do_scanningStopLED();
		}
		motor[grabber] = 0;
	}
	is_dropped = true;//'Cause we just released the object
}

void turn_right(int speed){// We may need a time variable here.
	writeDebugStreamLine("Turning right at speed %d ...",speed);
	do_lightRightLED();
	do_unlightLeftLED();
	motor[motor_left] = speed;
	motor[motor_right] = 0;
}

void turn_left(int speed){
	writeDebugStreamLine("Turning left at speed %d ...",speed);
	do_lightLeftLED();
	do_unlightRightLED();
	motor[motor_left] = 0;
	motor[motor_right] = speed;
}

void move_forward(int speed){
	writeDebugStreamLine("Moving forward at speed %d ...",speed);
	do_lightRightLED();
	do_lightLeftLED();
	motor[motor_left] = speed;
	motor[motor_right] = speed;
}

void move_reverse(int speed){
	writeDebugStreamLine("Reversing at speed %d ...",speed);
	do_unlightRightLED();
	do_unlightLeftLED();

	motor[motor_left] = -speed;
	motor[motor_right] = -speed;
}

void stop(){
	writeDebugStreamLine("Stopping motors...");
	motor[motor_left] = 0;
	motor[motor_right] = 0;
}

int get_rightLightSensor() {
	int sensorValue = SensorValue(r_lightSensor);
	writeDebugStreamLine("getting right light sensor %d...",sensorValue);
	return sensorValue;
}

int get_leftLightSensor() {
	int sensorValue = SensorValue(l_lightSensor);
	writeDebugStreamLine("getting left light sensor %d...",sensorValue);
	return sensorValue;
}

int get_sonarSensor(){
	int sensorValue = SensorValue(sonarSensor);
	writeDebugStreamLine("getting sonar sensor %d...",sensorValue);
	return sensorValue;
}

void do_reset(){
	//Clear debug window
	clearDebugStream();
	//Stop all motors
	stop();
	//Turn off all LED's
	do_scanningStopLED();
}
/*
The at_target function determines if the vehicle is at the target location.
It does this by measuring the distance to the nearest object and if within a stated distance returns true.
*/
bool at_target(){
	bool atTarget = false;
	writeDebugStreamLine("Checking if we are at target ...");
	atTarget = (get_sonarSensor()<=threshold); //Add infrared sensed value as well ie. && get_leftLightSensor() <= maxLight
	if(atTarget){
		do_lightCenterLED();
		}else{
		do_unlightCenterLED();
	}
	writeDebugStreamLine("at_Target = %d",atTarget);
	return atTarget;
}
/*This method will turn the vehicle left until its left sensor matches one provided by the calibration.
Once the left sensor detects that it is less than or equal to the lowest calibrated, the methiod exits.
*/
bool get_oriented(){
	bool oriented = false;
	while(!oriented){
		//turn_left(slow);
		if(get_leftLightSensor() <= leftLow || get_rightLightSensor() <= rightLow){
			oriented = true;
		}
	}
	return oriented;
}

/*This method allows the vehicle to track from the time/point it alligned with the LED bank to the target.
It calculates the difference between the right and left sensors to determine the direction of the light source (target)
It uses the average of five light sensor measurements and the calibration data to calculate the motor speed for each motor
*/
bool get_target(){
	if(get_oriented()){//We are facing the target, let's move there

		writeDebugStreamLine("Going home...");
		int l_sensorArray[] = {0,0,0,0,0};
		int r_sensorArray[] = {0,0,0,0,0};
		const int factor = 8;
		do{
			int L_sensor = 0;
			int R_sensor = 0;
			for(int i=0;i<5;i++){
				R_sensor = get_rightLightSensor();
				L_sensor = get_leftLightSensor();
				r_sensorArray[i] = R_sensor;
				l_sensorArray[i] = L_sensor;
				wait1Msec(10);
			}
			int l_sensors = 0;
			int r_sensors = 0;
			for(int i=0;i<5;i++){
				l_sensors+=l_sensorArray[i];
				r_sensors+=r_sensorArray[i];
			}

			int l_avg = floor(l_sensors/5);
			int r_avg = floor(r_sensors/5);

			/*
			//Maps both sensors to a scale of 0-20. 20 was chosen so the calculation doesn't overflow
			//Values deal with compensating for ambient light conditions
			*/
			leftValue = (l_avg - leftLow) * 20 / (leftHigh - leftLow);
			rightValue = (r_avg - rightLow) * 20 / (rightHigh - rightLow);

			diff = leftValue - rightValue; //get value of the difference between two signals

			//Run the motors
			turn_right(30 + (diff * factor));//motor[motor_left] = 30 + (diff * factor);
			turn_left(30 - (diff * factor));//motor[motor_right] = 30 - (diff * factor);

			//If the loop cycles too quickly, we get calculation errors. Therefore we regulate the speed by waiting a bit.
			wait1Msec(250);
		}while(!at_target());
	}
	return true;
}

/*
The do_finish function accepts an integer value representing the speed of the motors as it reverses and turns away from the object
Once moved away, it will then move to the edge of the arena and stop.
*/
void do_finish(int speed){
	writeDebugStreamLine("Finishing progam at speed %d...",speed);
	clearTimer(T1);
	while(time1[T1]<1000){
		move_reverse(speed);
		stop();
		wait1Msec(500);
		turn_left(speed);//replace slow with the value required for a 90degree turn
		stop();
	}
	if(get_sonarSensor()>100 || get_sonarSensor()<0){
		move_forward(fast);//Move faster if further away.
		}else{
		do{
			move_forward(get_sonarSensor());
		}while(get_sonarSensor()>threshold);
	}//move_forward until edge of ring
	stop();
	is_completed = true;
}
/*
This method records the high and low values of the ambient lighting in the room and stores the values in globa variables
The high and low values are recorded form the left and right sensors
*/
void do_calibrate(){
	writeDebugStreamLine("Calibrating...");
	//http://www.robotc.net/wikiarchive/Tutorials/Arduino_Projects/Mobile_Robotics/VEX/Program_to_use_Light_Sensor_to_find_light
	// Auto-calibration ended by button press. The button will begin the main function.
	while(!SensorValue(button1)) {
		do_scanningStartLED();
		leftValue = get_leftLightSensor();
		rightValue = get_rightLightSensor();

		//Get low and high values for the left sensor
		if(leftValue > leftHigh) {
			leftHigh = leftValue;//new left high signal
			} else if(leftValue < leftLow) {
			leftLow = leftValue;//new left low signal
		}

		//Get low and high values for the right sensor
		if(rightValue > rightHigh) {
			rightHigh = rightValue;//new right high signal
			} else if(rightValue < rightLow) {
			rightLow = rightValue;//new right low signal
		}
		do_scanningStopLED();
	}
}

task main ()
{
	T_STATES STATE = CALIBRATE;
	do_reset();
	while(true){
		monitorInput();
		switch(STATE){
		case CALIBRATE:
			writeDebugStreamLine("In CALIBRATE state...");
			do_calibrate();
			STATE=STOPPED;
			break;

		case STOPPED:
			writeDebugStreamLine("In STOPPED state...");
			if(button1_pushed){//Start program
				STATE = SCANNING;
				do_reset();
				button1_pushed = false;
			}
			if(! is_completed && at_target()){//If to edge of arena as per specification
				STATE = FINISH;
			}
			if(! is_completed && is_dropped){//If we dropped our payload but haven't finished
				STATE = FINISH;
			}
			if(! is_dropped && at_target()){//If we are at the target but haven't dropped the payload
				STATE = RELEASE;
			}
			if(is_dropped && is_completed){//If we dropped the payload and we completed our finish routine
				STATE = STOPPED;
			}
			break;

		case SCANNING:
			writeDebugStreamLine("In SCANNING state...");
			if(get_target()){//Scan will detect the strongest infrared signal. Returns 1 when found.
				STATE = FORWARD;//Move towards signal
				}else{
				STATE=STOPPED;
			}
			break;

		case FORWARD:
			writeDebugStreamLine("In FORWARD state...");
			while(!at_target()){
				if(get_sonarSensor()>100 || get_sonarSensor()<0){
					move_forward(slow);
					}else{
					move_forward(get_sonarSensor());
				}
			}
			STATE=STOPPED;
			break;

		case REVERSE:
			writeDebugStreamLine("In REVERSE state...");
			clearTimer(T1);
			while(time1[T1]<1000){
				move_reverse(fast);
			}
			STATE = STOPPED;
			break;

		case RELEASE:
			writeDebugStreamLine("In RELEASE state...");
			do_release(slow);
			STATE=STOPPED;
			break;

		case FINISH:
			writeDebugStreamLine("In FINISH state...");
			do_finish(slow);
			//is_completed=false;//set so we don't endlessly loop
			STATE = STOPPED;
			break;
		}
		wait1Msec(60);
	}
}
